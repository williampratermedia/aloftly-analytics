---
phase: 01-foundation
plan: 03
type: execute
wave: 3
depends_on:
  - 01-02
files_modified:
  - src/lib/supabase/client.ts
  - src/lib/supabase/server.ts
  - src/lib/supabase/service.ts
  - src/lib/auth/rbac.ts
  - src/lib/auth/middleware.ts
  - src/lib/vault.ts
  - src/middleware.ts
  - src/app/(auth)/login/page.tsx
  - src/app/(auth)/auth/callback/route.ts
  - src/app/(dashboard)/layout.tsx
autonomous: true
user_setup:
  - service: supabase
    why: "30-day session duration per user decision — Supabase default is 1 hour"
    dashboard_config:
      - task: "Set JWT expiry to 2592000 seconds (30 days): go to Authentication > Settings > JWT Expiry and enter 2592000"
        location: "Supabase Dashboard -> Authentication -> Settings -> JWT Expiry"
      - task: "Enable Google OAuth provider: go to Authentication > Providers > Google, enable it, and enter your Google OAuth Client ID and Client Secret"
        location: "Supabase Dashboard -> Authentication -> Providers -> Google"
requirements:
  - FOUN-02
  - FOUN-03
  - FOUN-04
  - FOUN-05

must_haves:
  truths:
    - "A user can sign in via magic link email and land on the dashboard"
    - "A user can sign in via Google OAuth and land on the dashboard"
    - "Unauthenticated requests to /dashboard routes redirect to /login"
    - "The middleware refreshes the Supabase session cookie on every request"
    - "getUserClient() returns a server client that enforces RLS via the user's JWT"
    - "getServiceClient() returns a service-role client that bypasses RLS — imported only in server-only paths"
    - "RBAC helper correctly evaluates role hierarchy: owner > admin > member > viewer"
  artifacts:
    - path: "src/lib/supabase/client.ts"
      provides: "Browser Supabase client for use client components"
      exports: ["createBrowserSupabaseClient"]
    - path: "src/lib/supabase/server.ts"
      provides: "Server Supabase client with cookie-based session (RLS enforced)"
      exports: ["getUserClient"]
    - path: "src/lib/supabase/service.ts"
      provides: "Service-role Supabase client for ingestion-only server paths"
      exports: ["getServiceClient"]
    - path: "src/lib/auth/rbac.ts"
      provides: "Role hierarchy, permission checks, hasPermission helper"
      exports: ["hasRole", "hasPermission", "ROLE_HIERARCHY"]
    - path: "src/middleware.ts"
      provides: "Session refresh + route protection middleware"
    - path: "src/app/(auth)/auth/callback/route.ts"
      provides: "PKCE code exchange for magic link and OAuth"
      exports: ["GET"]
    - path: "src/app/(auth)/login/page.tsx"
      provides: "Login page with magic link and Google OAuth buttons"
    - path: "src/lib/vault.ts"
      provides: "TypeScript wrapper for Vault RPC calls"
      exports: ["getCredential", "storeCredential"]
  key_links:
    - from: "src/middleware.ts"
      to: "@supabase/ssr"
      via: "createServerClient for session refresh on every request"
      pattern: "createServerClient"
    - from: "src/middleware.ts"
      to: "src/app/(auth)/login/page.tsx"
      via: "Redirect unauthenticated users to /login"
      pattern: "redirect.*login"
    - from: "src/app/(auth)/auth/callback/route.ts"
      to: "@supabase/ssr"
      via: "exchangeCodeForSession for PKCE flow"
      pattern: "exchangeCodeForSession"
    - from: "src/lib/vault.ts"
      to: "src/lib/supabase/service.ts"
      via: "Uses getServiceClient to call Vault RPC functions"
      pattern: "getServiceClient.*rpc"
    - from: "src/lib/supabase/server.ts"
      to: "next/headers cookies()"
      via: "Cookie-based session management"
      pattern: "cookies"
---

<objective>
Implement Supabase Auth with magic link and Google OAuth sign-in, typed Supabase client wrappers (user vs service), RBAC role hierarchy, session middleware, and Vault TypeScript helpers. Wire the complete auth flow from login through session management to route protection.

Purpose: Authentication and authorization are the security boundary for the entire application. The typed client wrappers enforce the user-client vs service-client separation that prevents accidental RLS bypass. Every future phase depends on this being correct.
Output: Working auth flow (magic link + Google OAuth), protected dashboard routes, RBAC helpers, and Vault TypeScript wrappers.
</objective>

<execution_context>
@C:/Users/billy/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/billy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create typed Supabase client wrappers, RBAC module, and Vault helpers</name>
  <files>
    src/lib/supabase/client.ts
    src/lib/supabase/server.ts
    src/lib/supabase/service.ts
    src/lib/auth/rbac.ts
    src/lib/auth/middleware.ts
    src/lib/vault.ts
  </files>
  <action>
    1. Create `src/lib/supabase/client.ts` — browser client for `"use client"` components (FOUN-05):
       - Export `createBrowserSupabaseClient()` using `createBrowserClient` from `@supabase/ssr`
       - Uses `NEXT_PUBLIC_SUPABASE_URL` and `NEXT_PUBLIC_SUPABASE_ANON_KEY`
       - This client enforces RLS automatically via the user's session token

    2. Create `src/lib/supabase/server.ts` — server client for server components and server actions (FOUN-05):
       - Export `async function getUserClient()` using `createServerClient` from `@supabase/ssr`
       - Uses `cookies()` from `next/headers` for cookie management
       - Implements the getAll/setAll cookie pattern from RESEARCH.md Pattern 1
       - This client enforces RLS — it reads the user's session from cookies
       - Add `import 'server-only'` at the top to prevent accidental client-side import

    3. Create `src/lib/supabase/service.ts` — service-role client for ingestion ONLY (FOUN-05):
       - Export `function getServiceClient()` using `createClient` from `@supabase/supabase-js`
       - Uses `SUPABASE_SERVICE_ROLE_KEY` (NOT a NEXT_PUBLIC_ var)
       - Set `{ auth: { persistSession: false } }`
       - Add `import 'server-only'` at the top — this file must NEVER be imported in client code
       - Add a JSDoc warning: "Service role bypasses RLS. Only use in ingestion routes and sync jobs."

    4. Create `src/lib/auth/rbac.ts` — role hierarchy and permission checks (FOUN-03):
       - Define `ROLE_HIERARCHY` as an ordered array: ['owner', 'admin', 'member', 'viewer'] (highest to lowest)
       - Export `hasRole(userRole: string, requiredRole: string): boolean` — returns true if userRole is equal to or higher than requiredRole in the hierarchy
       - Export `hasPermission(userRole: string, permission: string): boolean` — maps permissions to minimum required role:
         - 'manage_billing' → owner
         - 'manage_team' → admin
         - 'manage_integrations' → admin
         - 'manage_workspaces' → admin
         - 'use_dashboards' → member
         - 'manage_own_integrations' → member (within assigned workspaces)
         - 'view_dashboards' → viewer
         - 'export_data' → viewer
       - Export the permission map as a typed constant for reuse

    5. Create `src/lib/auth/middleware.ts` — org context extraction helper:
       - Export `async function getOrgContext(supabase)` that calls `supabase.auth.getUser()` (NOT getSession — security critical per RESEARCH.md Pitfall 4)
       - Extracts org_id, user_role from the user's JWT claims (via `user.app_metadata` or by decoding the access token)
       - Returns `{ orgId, userId, role, user }` or null if unauthenticated
       - This is a helper used by server components and API routes to get the current org context

    6. Create `src/lib/vault.ts` — TypeScript wrapper for Vault RPC functions (FOUN-09):
       - Import `getServiceClient` from `src/lib/supabase/service`
       - Export `async function storeCredential(secret: string, name: string, description?: string): Promise<string>` — calls `rpc('store_integration_credential', ...)`, returns the Vault secret ID
       - Export `async function getCredential(secretId: string): Promise<string>` — calls `rpc('get_integration_credential', ...)`, returns the decrypted secret value
       - Both functions throw on error with descriptive messages
       - Add `import 'server-only'` — credentials must never be accessed client-side
  </action>
  <verify>
    - `npx tsc --noEmit` passes with all new files
    - `src/lib/supabase/server.ts` contains `import 'server-only'`
    - `src/lib/supabase/service.ts` contains `import 'server-only'`
    - `src/lib/vault.ts` contains `import 'server-only'`
    - `src/lib/auth/rbac.ts` exports hasRole, hasPermission, ROLE_HIERARCHY
    - hasRole('admin', 'member') returns true; hasRole('viewer', 'admin') returns false
  </verify>
  <done>
    Three typed Supabase client wrappers exist with correct server-only guards. RBAC module implements the 4-role hierarchy with permission mapping. Vault TypeScript helpers wrap the service-role RPC functions. Org context helper extracts org_id and role from JWT claims using getUser().
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement auth flow — middleware, login page, callback route, and dashboard shell</name>
  <files>
    src/middleware.ts
    src/app/(auth)/login/page.tsx
    src/app/(auth)/auth/callback/route.ts
    src/app/(dashboard)/layout.tsx
  </files>
  <action>
    1. Create `src/middleware.ts` — session refresh + route protection (FOUN-02, FOUN-04):
       - Follow RESEARCH.md Pattern 2 exactly
       - Create a Supabase server client with cookie getAll/setAll on the NextRequest/NextResponse
       - Call `supabase.auth.getUser()` to refresh the session (NOT getSession — security critical)
       - Protected routes: anything under `/(dashboard)` or starting with `/dashboard`, `/settings`
       - Public routes: `/login`, `/auth/callback`, `/api/health`, `/api/webhooks/*`
       - If user is not authenticated and hits a protected route → redirect to `/login`
       - If user IS authenticated and hits `/login` → redirect to `/dashboard`
       - Export `config.matcher` excluding `_next/static`, `_next/image`, `favicon.ico`, and static assets

    2. Create `src/app/(auth)/login/page.tsx` — login page (FOUN-02):
       - "use client" component
       - Import `createBrowserSupabaseClient` from `src/lib/supabase/client`
       - Display "Aloftly Analytics" branding with the violet accent color (#7c3aed)
       - Two sign-in options per user decision (magic link + Google OAuth ONLY — no passwords):
         a. **Magic link**: Email input field + "Send magic link" button. Calls `supabase.auth.signInWithOtp({ email, options: { emailRedirectTo: origin + '/auth/callback' } })`
         b. **Google OAuth**: "Continue with Google" button. Calls `supabase.auth.signInWithOAuth({ provider: 'google', options: { redirectTo: origin + '/auth/callback' } })`
       - After magic link is sent, show a confirmation message: "Check your email for a magic link"
       - Handle loading states on both buttons
       - Handle error states (display error message from Supabase)
       - Use shadcn/ui components: Button, Input, Card
       - Install needed shadcn components: `npx shadcn@latest add button input card`
       - Clean, minimal design — white card centered on page, violet accent on primary button
       - Light-mode-first (per CLAUDE.md design guardrails)

    3. Create `src/app/(auth)/auth/callback/route.ts` — PKCE code exchange (FOUN-02):
       - Follow RESEARCH.md Pattern 8 exactly
       - GET route handler
       - Extract `code` from searchParams
       - Create Supabase server client with cookies
       - Call `supabase.auth.exchangeCodeForSession(code)`
       - On success: redirect to `next` param or `/dashboard` (default). NOTE: The full onboarding wizard (PROD-05) is Phase 4 scope — do NOT redirect to /onboarding here. Phase 4 will update this redirect when the wizard is built.
       - On error: redirect to `/login?error=auth-code-error`

    4. Create `src/app/(dashboard)/layout.tsx` — authenticated dashboard shell:
       - Server component
       - Import `getUserClient` from `src/lib/supabase/server`
       - Call `getUserClient()` then `supabase.auth.getUser()` to verify auth
       - If no user, redirect to `/login` (belt-and-suspenders with middleware)
       - Render a minimal shell layout for now:
         - A placeholder left sidebar div (dark slate bg, fixed width 256px) with "Aloftly" text at top
         - A main content area (light gray bg) with `{children}`
       - This is a structural placeholder — the full sidebar with workspace switcher, nav links, breadcrumbs will be built in Phase 4. Do NOT over-build the UI here.
       - Include a simple sign-out button in the sidebar that calls `supabase.auth.signOut()` and redirects to `/login`

    5. Create a placeholder page at `src/app/(dashboard)/page.tsx` that renders "Dashboard" heading — proves the auth flow works end-to-end.

    CRITICAL per user decision: Magic link + Google OAuth ONLY. Do NOT implement email/password sign-in. The REQUIREMENTS.md mentions "email/password" but the user explicitly locked to "no passwords" in CONTEXT.md — honor the user's locked decision.

    CRITICAL per RESEARCH.md: Use `getUser()` not `getSession()` in all server-side auth checks. getSession() trusts the cookie without validation; getUser() re-validates with Supabase Auth server.
  </action>
  <verify>
    - `npm run build` passes without errors
    - `src/middleware.ts` uses `getUser()` not `getSession()`
    - `src/app/(auth)/login/page.tsx` has magic link and Google OAuth — no password fields
    - `src/app/(auth)/auth/callback/route.ts` calls `exchangeCodeForSession`
    - `src/app/(dashboard)/layout.tsx` checks auth and renders sidebar shell
    - Navigating to `/dashboard` without auth redirects to `/login`
    - The login page renders with shadcn/ui components and violet accent
  </verify>
  <done>
    Complete auth flow works: middleware refreshes sessions and protects routes, login page offers magic link and Google OAuth, callback route exchanges PKCE codes, dashboard layout verifies auth and renders a minimal shell. No password sign-in exists. All server-side auth uses getUser() for security.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes with all auth files
2. Middleware redirects unauthenticated users from /dashboard to /login
3. Middleware redirects authenticated users from /login to /dashboard
4. Login page shows magic link input and Google OAuth button — no password field
5. Auth callback route exchanges PKCE code and redirects
6. getUserClient() enforces RLS via cookies; getServiceClient() uses service_role key
7. Both server.ts and service.ts have `import 'server-only'` guards
8. RBAC hasRole correctly evaluates the 4-tier hierarchy
9. Vault helpers call RPC functions via service client
</verification>

<success_criteria>
- Magic link and Google OAuth sign-in work end-to-end
- Session middleware refreshes cookies and protects routes using getUser()
- Three typed Supabase client wrappers with correct access boundaries
- RBAC module with role hierarchy and permission mapping
- Vault TypeScript helpers for encrypted credential storage/retrieval
- Minimal dashboard shell proves the auth flow works
- No password-based authentication anywhere
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
